<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>WebCL example 1 (Hello World)</title>

 
<script id="clStrips" type="text/x-opencl">
__kernel void ckStrips(__global uint* pointsByY, 
		       __global uint* pointsByX,
		       __global uint *diffs,
		       __global uint* strip,
		       unsigned int numPoints,
		       unsigned int maxStripSize
    ) 
    {
#define UINT4(var, idx) ((uint4)(var[4 * (idx)], var[4 * (idx) + 1], var[4 * (idx) + 2], var[4 * (idx) + 3]))
#define UINT3(var, idx) ((uint3)(var[3 * (idx)], var[3 * (idx) + 1], var[3 * (idx) + 2]))
#define UINT2(var, idx) ((uint2)(var[2 * (idx)], var[2 * (idx) + 1]))
#define SETUINT4s0(var, idx) (var[4 * (idx)])
#define SETUINT4s1(var, idx) (var[4 * (idx) + 1])
#define SETUINT4s2(var, idx) (var[4 * (idx) + 2])
#define SETUINT4s3(var, idx) (var[4 * (idx) + 3])

#define SETUINT3s0(var, idx) (var[3 * (idx)])
#define SETUINT3s1(var, idx) (var[3 * (idx) + 1])
#define SETUINT3s2(var, idx) (var[3 * (idx) + 2])

#define SETUINT2s0(var, idx) (var[2 * (idx)])
#define SETUINT2s1(var, idx) (var[2 * (idx) + 1])

#define SETUINT4(lhs, idx1, rhs) SETUINT4s0(lhs, idx1) = (rhs).s0; SETUINT4s1(lhs, idx1) = (rhs).s1; SETUINT4s2(lhs, idx1) = (rhs).s2; SETUINT4s3(lhs, idx1) = (rhs).s3; 
#define SETUINT3(lhs, idx1, rhs) SETUINT3s0(lhs, idx1) = (rhs).s0; SETUINT3s1(lhs, idx1) = (rhs).s1; SETUINT3s2(lhs, idx1) = (rhs).s2;
#define SETUINT2(lhs, idx1, rhs) SETUINT2s0(lhs, idx1) = (rhs).s0; SETUINT2s1(lhs, idx1) = (rhs).s1;
     
  unsigned int strip_idx = get_global_id(0);
  // round up to handle cases where numPoints is not a multiple of 
  // maxStripSize.
  unsigned int numStrips = (numPoints + maxStripSize - 1)/maxStripSize;
  unsigned int stripLength = 0;
  long xMidPoint = 0;
  if (strip_idx > numStrips || numPoints <= 2){
    return;
  }
  unsigned int xMidPointIdx = (maxStripSize/2 - 1) + maxStripSize * strip_idx;

  // use min to handle the case for non power of 2 points.
  xMidPointIdx = min(xMidPointIdx, numPoints - 1);
  xMidPoint = UINT3(pointsByX,xMidPointIdx).x;

  float diffDist1 = distance(convert_float2(UINT4(diffs, strip_idx * maxStripSize/2).lo), 
  convert_float2(UINT4(diffs, strip_idx * maxStripSize/2).hi));
  
  printf("strip_idx, maxStripSize, maxStripSize/2: %u, %u, %u\n", strip_idx, maxStripSize, maxStripSize/2);

  // the strip_idx * maxStripSize/2 + maxStripSize/4 + 1 < numPoints check is to handle
  // cases where strip2 doesn't exist, e.g. numPoints = 15 and maxStripSize = 4, then 
  // diff[strip_idx * maxStripSize/2 + maxStripSize/4] won't have been calculated by ckDiffs
  if (strip_idx * maxStripSize/2 + maxStripSize/4 < (numPoints+1)/2)
  {
    float diffDist2 = distance(convert_float2(UINT4(diffs, strip_idx * maxStripSize/2 + 1 * maxStripSize/4).lo), 
    convert_float2(UINT4(diffs, strip_idx * maxStripSize/2 + 1 * maxStripSize/4).hi));
      if (diffDist2 < diffDist1) 
      {
        SETUINT4(diffs, strip_idx * maxStripSize/2, UINT4(diffs, strip_idx * maxStripSize/2 + 1 * maxStripSize/4));    
	printf("diffs[strip_idx * maxStripSize/2]: %u, %u, %u, %u\n", UINT4(diffs, strip_idx * maxStripSize/2).s0, UINT4(diffs, strip_idx * maxStripSize/2).s1, UINT4(diffs, strip_idx * maxStripSize/2).s2, UINT4(diffs, strip_idx * maxStripSize/2).s3);
      }
  }
  float diffDist = distance(convert_float2(UINT4(diffs, strip_idx * maxStripSize/2).lo), convert_float2(UINT4(diffs, strip_idx * maxStripSize/2).hi));
  uint minIdx = strip_idx * maxStripSize;

  uint maxIdx = min(strip_idx * maxStripSize + maxStripSize - 1, numPoints - 1);
  for (uint i = 0; i < numPoints; i++){
    float dist = fabs(UINT3(pointsByY, i).x - xMidPoint);
    if (dist < diffDist && (UINT3(pointsByY, i).s2 >= minIdx && UINT3(pointsByY, i).s2 <= maxIdx))	  
      {
          SETUINT2(strip, strip_idx * maxStripSize + stripLength, (UINT3(pointsByY, i).xy));
          //strip[strip_idx * maxStripSize + stripLength] = UINT3(pointsByY, i).xy;
	  stripLength++;
      }       
  }

  for (uint i = 0; i < stripLength; i++) {
      uint j = i + 1;
      float diffDist = distance(convert_float2(UINT4(diffs, strip_idx * maxStripSize/2).lo), convert_float2(UINT4(diffs, strip_idx * maxStripSize/2).hi));
      while(j < stripLength && fabs(UINT2(strip, strip_idx * maxStripSize + i).y - UINT2(strip, strip_idx * maxStripSize + j).y) < diffDist) {
        diffDist = distance(convert_float2(UINT4(diffs, strip_idx * maxStripSize/2).lo), convert_float2(UINT4(diffs, strip_idx * maxStripSize/2).hi));
        if (diffDist > distance(convert_float2(UINT2(strip, strip_idx * maxStripSize + i)), convert_float2(UINT2(strip, strip_idx * maxStripSize + j))))
	  {
	      SETUINT4s0(diffs, strip_idx * maxStripSize/2) = UINT2(strip, strip_idx * maxStripSize + i).x;
              SETUINT4s1(diffs, strip_idx * maxStripSize/2) = UINT2(strip, strip_idx * maxStripSize + i).y;

	      SETUINT4s2(diffs, strip_idx * maxStripSize/2) = UINT2(strip, strip_idx * maxStripSize + j).x;
              SETUINT4s3(diffs, strip_idx * maxStripSize/2) = UINT2(strip, strip_idx * maxStripSize + j).y;
	      printf("diffs[strip_idx * maxStripSize/2]: %u, %u, %u, %u\n", UINT4(diffs, strip_idx * maxStripSize/2).s0, UINT4(diffs, strip_idx * maxStripSize/2).s1, UINT4(diffs, strip_idx * maxStripSize/2).s2, UINT4(diffs, strip_idx * maxStripSize/2).s3);
	  }
	  j++;
      }
  }
}
</script>    


<script id="clDiffs" type="text/x-opencl">
#pragma OPENCL EXTENSION all : enable
__kernel void ckDiffs(__global uint* points, 
		      __global uint* diffs, 
                      unsigned int numPoints) {
  unsigned int idx = get_global_id(0);
  // compute the distance
  if (idx <= numPoints/2 - 1) {
      diffs[idx * 4] = points[(idx * 2) * 3];
      diffs[idx * 4 + 1] = points[(idx * 2) * 3 + 1];

      diffs[idx * 4 + 2] = points[(idx * 2 + 1) * 3];
      diffs[idx * 4 + 3] = points[(idx * 2 + 1) * 3 + 1];
      

      printf("diffs[idx * 4 + 0-3]: %u, %u, %u, %u\n", diffs[idx * 4], diffs[idx * 4 + 1], diffs[idx * 4 + 2], diffs[idx * 4 + 3]);      
  }
  // if the number of points is not even, e.g numPoints = 15
  // then the last diff borrows from idx * 2 - 1.
  else if (numPoints % 2 && idx == (numPoints+1)/2 -1)
  {      
      diffs[idx * 4]     = points[(idx * 2) * 3];
      diffs[idx * 4 + 1] = points[(idx * 2) * 3 + 1];

      diffs[idx * 4 + 2] = points[(idx * 2 - 1) * 3];
      diffs[idx * 4 + 3] = points[(idx * 2 - 1) * 3 + 1];
      printf("diffs[idx * 4 + 0-3]: %u, %u, %u, %u\n", diffs[idx * 4], diffs[idx * 4 + 1], diffs[idx * 4 + 2], diffs[idx * 4 + 3]);      
  }
}
</script>    


  

<script type="text/javascript">
function loadKernel(id){
  var kernelElement = document.getElementById(id);
  var kernelSource = kernelElement.text;
  if (kernelElement.src != "") {
      var mHttpReq = new XMLHttpRequest();
      mHttpReq.open("GET", kernelElement.src, false);
      mHttpReq.send(null);
      kernelSource = mHttpReq.responseText;
  } 
  return kernelSource;
}

function CL_ClosestPair (points, print_output, return_timing_info) {
    points = points.slice(0);
    // All output is written to element by id "output"
    var output = document.getElementById("output");
    //output.innerHTML = "";
    try 
    {
	// First check if the WebCL extension is installed at all 
	if (window.WebCL == undefined) {
	    alert("Unfortunately your system does not support WebCL. " +
		  "Make sure that you have both the OpenCL driver " +
		  "and the WebCL browser extension installed.");
	    return false;
	}
	// Generate input vectors
	var numPoints = points.length;
	var pointsByX = new Uint32Array(numPoints          * 3); // * 3 since pointsByX is a 3 field structure.
	var pointsByY = new Uint32Array(numPoints          * 3);
	var diffs     = new Uint32Array(Math.floor((numPoints + 1)/2)  * 4); // * 4 since diffs is a 4 field structure
	var strips    = new Uint32Array(numPoints * 2      * 2);

	// Create points
	if (print_output == undefined)
	{
	    output.innerHTML += "<br/>Num Points: " + numPoints + "<br/>";
	}
	// Populate pointsByX
 	// sort by x-coordinate
	points.sort(function (a,b){return a[0] - b[0];});
	if (print_output == undefined)
	{
	    output.innerHTML += "points:";
	}
	for (var i = 0; i < numPoints; i++)
	{
	    pointsByX[3 * i] = points[i][0];
	    pointsByX[3 * i + 1] = points[i][1];
	    if (print_output == undefined)
	    {
		output.innerHTML += "(" + points[i][0] + ", " + points[i][1] + "),";
	    }
	    pointsByX[3 * i + 2] = i;
	}
	// Populate pointsByY
	// sort by y-coordinate
	points.sort(function (a,b){return b[1] - a[1];});
	for (var i = 0; i < numPoints; i++)
	{
	    pointsByY[3 * i] = points[i][0]; 
	    pointsByY[3 * i + 1] = points[i][1];
	    pointsByY[3 * i + 2] = i;
	}
                  

	
	// Setup WebCL context using the default device of the first available platform 
	var platforms = WebCL.getPlatformIDs();
	var ctx = WebCL.createContextFromType ([WebCL.CL_CONTEXT_PLATFORM, platforms[0]],
					       WebCL.CL_DEVICE_TYPE_DEFAULT);
	// Reserve buffers
	var ckPointsByX = ctx.createBuffer (WebCL.CL_MEM_READ_WRITE, 4 * pointsByX.length);
	var ckPointsByY = ctx.createBuffer (WebCL.CL_MEM_READ_WRITE, 4 * pointsByY.length);
	var ckDiffs     = ctx.createBuffer (WebCL.CL_MEM_READ_WRITE, 4 * diffs.length);
	var ckStrips    = ctx.createBuffer (WebCL.CL_MEM_READ_WRITE, 4 * strips.length);

	// Create and build program for the first device
	var kernelSrcDiffs = loadKernel("clDiffs");
	var programDiffs = ctx.createProgramWithSource(kernelSrcDiffs);
	var kernelSrcStrips = loadKernel("clStrips");
	var programStrips = ctx.createProgramWithSource(kernelSrcStrips);

	var devices = ctx.getContextInfo(WebCL.CL_CONTEXT_DEVICES);
	
	try {
	    programDiffs.buildProgram ([devices[0]], "");
	    programStrips.buildProgram ([devices[0]], "");
	} catch(e) {
	    alert ("Failed to build WebCL program. Error "
		   + program.getProgramBuildInfo (devices[0], WebCL.CL_PROGRAM_BUILD_STATUS)
		   + ":  " + program.getProgramBuildInfo (devices[0], WebCL.CL_PROGRAM_BUILD_LOG));
	    throw e;
	}
	// Create command queue using the first available device
	var cmdQueue = ctx.createCommandQueue (devices[0], 0);
	var start_time = (new Date()).getTime();
	// Write the buffers to OpenCL device memory
	cmdQueue.enqueueWriteBuffer (ckPointsByX, true, 0, 4 * pointsByX.length, pointsByX, []);
	cmdQueue.enqueueWriteBuffer (ckPointsByY, true, 0, 4 * pointsByY.length, pointsByY, []);
	cmdQueue.enqueueWriteBuffer (ckDiffs, true, 0, 4 * diffs.length, diffs, []);
	cmdQueue.enqueueWriteBuffer (ckStrips, true, 0, 4 * strips.length, strips, []);

	var kernelDiffs = programDiffs.createKernel ("ckDiffs");
	var kernelStrips = programStrips.createKernel ("ckStrips");
	// Compute diffs
	kernelDiffs.setKernelArg(0, ckPointsByX);
	kernelDiffs.setKernelArg(1, ckDiffs);
	kernelDiffs.setKernelArg(2, numPoints, WebCL.types.UINT);
	// +1 to handle the case where numPoints is not even
	var globalWorkSize = [Math.floor((numPoints + 1)/2)];
	var localWorkSize = 1;
	cmdQueue.enqueueNDRangeKernel(kernelDiffs, globalWorkSize.length, [], globalWorkSize, [], []);
	cmdQueue.finish();
	for (maxStripSize = 4; maxStripSize <= numPoints || (maxStripSize > numPoints && (maxStripSize/2 < numPoints)); maxStripSize *= 2){
	    // Compute strips
	    kernelStrips.setKernelArg(0, ckPointsByY);
	    kernelStrips.setKernelArg(1, ckPointsByX);
	    kernelStrips.setKernelArg(2, ckDiffs);
	    kernelStrips.setKernelArg(3, ckStrips);
	    kernelStrips.setKernelArg(4, numPoints, WebCL.types.UINT);
	    kernelStrips.setKernelArg(5, maxStripSize, WebCL.types.UINT);
	    // + maxStripSize - 1 to handle the case where numPoints is not 
	    // a multiple of maxStripSize e.g. maxStripSize = 4 and numPoints = 15
	    var numStrips = (numPoints + maxStripSize - 1)/maxStripSize;
	    globalWorkSize = [numStrips];
	    localWorkSize = 1;
	    cmdQueue.enqueueNDRangeKernel(kernelStrips, globalWorkSize.length, [], globalWorkSize, [], []);
	    cmdQueue.finish();
	}
	cmdQueue.enqueueReadBuffer(ckDiffs, true, 0, diffs.length * 4, diffs, []);
	var diff = (new Date()).getTime() - start_time;
	if (print_output == undefined)
	{
	    output.innerHTML += "<br/>";
	    output.innerHTML += "OCL Closest Pair: (" + diffs[0] + ", " + diffs[1] + "), (" + diffs[2] + ", " + diffs[3] + ")";
	    output.innerHTML += "<br/>";
	}
	// release resources
	/*clReleaseMemObject(ckPointsByX);
	clReleaseMemObject(ckPointsByY);
	clReleaseMemObject(ckDiffs);
	clReleaseMemObject(ckStrips);*/
	//return [[diffs[0], diffs[1]], [diffs[2], diffs[3]]];
	if (return_timing_info == undefined)
	{
	    return 0;
	} else
	{
	    return [diff, diffs[0], diffs[1], diffs[2], diffs[3]];
	}
    } catch(e) {
	document.getElementById("output").innerHTML += "<h3>ERROR:</h3><pre style=\"color:red;\">" + e.message + "</pre>";
	throw e;
    }
}
</script>                 

<script type="text/javascript">
function detectCL() {
  // First check if the WebCL extension is installed at all
  
  if (window.WebCL == undefined) {
    alert("Unfortunately your system does not support WebCL. " +
          "Make sure that you have both the OpenCL driver " +
          "and the WebCL browser extension installed.");
    return false;
  }

  // Get a list of available CL platforms, and another list of the
  // available devices on each platform. If there are no platforms,
  // or no available devices on any platform, then we can conclude
  // that WebCL is not available.

  try {
    var platforms = WebCL.getPlatformIDs();
    var devices = [];
    for (var i in platforms) {
      var plat = platforms[i];
      devices[i] = plat.getDeviceIDs(WebCL.CL_DEVICE_TYPE_ALL);
    }
  } catch (e) {
    alert("Unfortunately platform or device inquiry failed.");
  }
}
</script>
<script type="text/javascript" src="closest_pair.js"></script>
<script type="text/javascript" src="timing_code.js"></script>
</head>
<body onload="CL_ClosestPair(points); drawPoints();">
<canvas id="canvas" width="800" height="600"><p>Fallback content goes here.</p></canvas>    
<script type="text/javascript">
  detectCL();
</script>
<div id="output">
</div> 
<button type="button" onclick="TimeOCL_JS();">Time OCL & JS</button>
<div id="TimingInfo"</div>
</body>
</html>
