<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>WebCL example 1 (Hello World)</title>

 
<script id="clStrips" type="text/x-opencl">
    //#pragma OPENCL EXTENSION all : enable
__kernel void ckStrips(__global uint3* pointsByY, 
		       __global uint3* pointsByX,
		       __global uint4 *diffs,
		       __global uint2* strip,
		       unsigned int numPoints,
		       unsigned int maxStripSize
    ) 
    {
  unsigned int strip_idx = get_global_id(0);
  // round up to handle cases where numPoints is not a multiple of 
  // maxStripSize.
  unsigned int numStrips = (numPoints + maxStripSize - 1)/maxStripSize;
  unsigned int stripLength = 0;
  long xMidPoint = 0;
  if (strip_idx > numStrips || numPoints <= 2){
    return;
  }

  unsigned int xMidPointIdx = (maxStripSize/2 - 1) + maxStripSize * strip_idx;

  // use min to handle the case for non power of 2 points.
  xMidPointIdx = min(xMidPointIdx, numPoints - 1);
  xMidPoint = pointsByX[xMidPointIdx].x;
    //printf("strip_idx: %d, maxStripSize: %d, xMidPoint: %d\n", strip_idx, maxStripSize, xMidPoint);
  float diffDist1 = distance(convert_float2(diffs[strip_idx * maxStripSize/2].lo), 
			     convert_float2(diffs[strip_idx * maxStripSize/2].hi));

  // the strip_idx * maxStripSize/2 + maxStripSize/4 + 1 < numPoints check is to handle
  // cases where strip2 doesn't exist, e.g. numPoints = 15 and maxStripSize = 4, then 
  // diff[strip_idx * maxStripSize/2 + maxStripSize/4] won't have been calculated by ckDiffs
  if (strip_idx * maxStripSize/2 + maxStripSize/4 < (numPoints+1)/2)
  {
      float diffDist2 = distance(convert_float2(diffs[strip_idx * maxStripSize/2 + 1 * maxStripSize/4].lo), 
				 convert_float2(diffs[strip_idx * maxStripSize/2 + 1 * maxStripSize/4].hi));
      if (diffDist2 < diffDist1) 
      {
	  diffs[strip_idx * maxStripSize/2] = diffs[strip_idx * maxStripSize/2 + 1 * maxStripSize/4];
      }
  }
  float diffDist = distance(convert_float2(diffs[strip_idx * maxStripSize/2].lo), convert_float2(diffs[strip_idx * maxStripSize/2].hi));
  long minIdx = strip_idx * maxStripSize;

  long maxIdx = min(strip_idx * maxStripSize + maxStripSize - 1, numPoints - 1);
    //printf("minIdx, maxIdx: %ld, %ld\n", minIdx, maxIdx);
    //printf("numPoints: %d, arg1: %d, arg2: %d\n", numPoints, strip_idx * maxStripSize + maxStripSize - 1, numPoints-1);
  for (int i = 0; i < numPoints; i++){
      float dist = fabs(pointsByY[i].x - xMidPoint);
      if (dist < diffDist && (pointsByY[i].s2 >= minIdx && pointsByY[i].s2 <= maxIdx))	  
      {
	  strip[strip_idx * maxStripSize + stripLength] = pointsByY[i].xy;
	  stripLength++;
	  //printf("stripLength: %d, pointsByY[i].xy: %d, %d, %d\n", stripLength, pointsByY[i].x, pointsByY[i].y, pointsByY[i].s2);
      }       
  }

  for (int i = 0; i < stripLength; i++) {
      int j = i + 1;
      float diffDist = distance(convert_float2(diffs[strip_idx * maxStripSize/2].lo), convert_float2(diffs[strip_idx * maxStripSize/2].hi));
      //printf("s_diffDist:%f\n", diffDist);
      //printf("strip[i].y, strip[j].y, strip_diff:(%d, %d, %f)\n", strip[strip_idx * maxStripSize + i].y, strip[strip_idx * maxStripSize + j].y, fabs((int)strip[strip_idx * maxStripSize + i].y - (int)strip[strip_idx * maxStripSize + j].y));
      while(j < stripLength && fabs((long)strip[strip_idx * maxStripSize + i].y - (long)strip[strip_idx * maxStripSize + j].y) < diffDist) {
	  diffDist = distance(convert_float2(diffs[strip_idx * maxStripSize/2].lo), convert_float2(diffs[strip_idx * maxStripSize/2].hi));
	  if (diffDist > distance(convert_float2(strip[strip_idx * maxStripSize + i]), convert_float2(strip[strip_idx * maxStripSize + j])))
	  {
	      diffs[strip_idx * maxStripSize/2].lo = strip[strip_idx * maxStripSize + i];
	      diffs[strip_idx * maxStripSize/2].hi = strip[strip_idx * maxStripSize + j];
	      /*printf("strip_idx * maxStripSize/2: %d, ", strip_idx * maxStripSize/2);
	      printf("diffs[].lo: %d, %d, ", diffs[strip_idx * maxStripSize/2].s0, diffs[strip_idx * maxStripSize/2].s1);
	      printf("diffs[].hi: %d, %d\n", diffs[strip_idx * maxStripSize/2].s2, diffs[strip_idx * maxStripSize/2].s3);*/
		     
	  }
	  j++;
      }
  }
}
</script>    


<script id="clDiffs" type="text/x-opencl">
      //#pragma OPENCL EXTENSION all : enable
__kernel void ckDiffs(__global uint3* points, 
		      __global uint3* diffs, 
                      unsigned int numPoints) {
  unsigned int idx = get_global_id(0);
  // compute the distance
  if (idx <= numPoints/2 - 1) {
      //printf("idx: %d, idx * 2: %d, points[idx * 2].x: %d, points[idx * 2].y: %d\n", idx, idx * 2, points[idx * 2].x, points[idx * 2].y);
      diffs[idx].hi = points[idx * 2 + 1].xy;
      diffs[idx].lo = points[idx * 2].xy;
  }
  // if the number of points is not even, e.g numPoints = 15
  // then the last diff borrows from idx * 2 - 1.
  else if (numPoints % 2 && idx == (numPoints+1)/2 -1)
  {      
      diffs[idx].hi = points[idx * 2 - 1].xy;
      diffs[idx].lo = points[idx * 2].xy;
  }
}
</script>    


  

<script type="text/javascript">
function loadKernel(id){
  var kernelElement = document.getElementById(id);
  var kernelSource = kernelElement.text;
  if (kernelElement.src != "") {
      var mHttpReq = new XMLHttpRequest();
      mHttpReq.open("GET", kernelElement.src, false);
      mHttpReq.send(null);
      kernelSource = mHttpReq.responseText;
  } 
  return kernelSource;
}

function CL_ClosestPair (points, print_output, return_timing_info) {
    points = points.slice(0);
    // All output is written to element by id "output"
    var output = document.getElementById("output");
    //output.innerHTML = "";
    try 
    {
	// First check if the WebCL extension is installed at all 
	if (window.WebCL == undefined) {
	    alert("Unfortunately your system does not support WebCL. " +
		  "Make sure that you have both the OpenCL driver " +
		  "and the WebCL browser extension installed.");
	    return false;
	}
	// Generate input vectors
	var numPoints = points.length;
	var pointsByX = new Uint32Array(numPoints          * 4); // * 4 since pointsByX is uint3 OpenCL type which is of size 4 * sizeof(uint) per the OpenCL spec.
	var pointsByY = new Uint32Array(numPoints          * 4); // ""
	var diffs     = new Uint32Array(Math.floor((numPoints + 1)/2)  * 4); // * 4 since diffs is a 4 field structure
	var strips    = new Uint32Array(numPoints * 2      * 2);

	// Create points
	if (print_output == undefined)
	{
	    output.innerHTML += "<br/>Num Points: " + numPoints + "<br/>";
	}

	// Populate pointsByX
 	// sort by x-coordinate
	points.sort(function (a,b){return a[0] - b[0];});
	if (print_output == undefined)
	{
	    output.innerHTML += "points:";
	}
	pointsByXC = [];
	for (var i = 0; i < numPoints; i++)
	{
	    pointsByX[4 * i] = points[i][0];
	    pointsByX[4 * i + 1] = points[i][1];
	    if (print_output == undefined)
	    {
		output.innerHTML += "(" + points[i][0] + ", " + points[i][1] + "),";
	    }
	    pointsByX[4 * i + 2] = i;
	    pointsByXC.push([points[i][0],points[i][1], i]);
	}
	// Populate pointsByY
	// sort by y-coordinate
	pointsByXC.sort(function (a,b){return a[1] - b[1];});
	for (var i = 0; i < numPoints; i++)
	{
	    pointsByY[4 * i] = pointsByXC[i][0]; 
	    pointsByY[4 * i + 1] = pointsByXC[i][1];
	    pointsByY[4 * i + 2] = pointsByXC[i][2];
	}
                  

	
	// Setup WebCL context using the default device of the first available platform 
	var platforms = WebCL.getPlatformIDs();
	var ctx = WebCL.createContextFromType ([WebCL.CL_CONTEXT_PLATFORM, platforms[0]],
					       WebCL.CL_DEVICE_TYPE_DEFAULT);
	// Reserve buffers
	var ckPointsByX = ctx.createBuffer (WebCL.CL_MEM_READ_WRITE, 4 * pointsByX.length);
	var ckPointsByY = ctx.createBuffer (WebCL.CL_MEM_READ_WRITE, 4 * pointsByY.length);
	var ckDiffs     = ctx.createBuffer (WebCL.CL_MEM_READ_WRITE, 4 * diffs.length);
	var ckStrips    = ctx.createBuffer (WebCL.CL_MEM_READ_WRITE, 4 * strips.length);

	// Create and build program for the first device
	var kernelSrcDiffs = loadKernel("clDiffs");
	var programDiffs = ctx.createProgramWithSource(kernelSrcDiffs);
	var kernelSrcStrips = loadKernel("clStrips");
	var programStrips = ctx.createProgramWithSource(kernelSrcStrips);

	var devices = ctx.getContextInfo(WebCL.CL_CONTEXT_DEVICES);
	
	try {
	    programDiffs.buildProgram ([devices[0]], "");
	    programStrips.buildProgram ([devices[0]], "");
	} catch(e) {
	    alert ("Failed to build WebCL program. Error "
		   + program.getProgramBuildInfo (devices[0], WebCL.CL_PROGRAM_BUILD_STATUS)
		   + ":  " + program.getProgramBuildInfo (devices[0], WebCL.CL_PROGRAM_BUILD_LOG));
	    throw e;
	}
	// Create command queue using the first available device
	var cmdQueue = ctx.createCommandQueue (devices[0], 0);
	var start_time = (new Date()).getTime();	
	// Write the buffers to OpenCL device memory
	cmdQueue.enqueueWriteBuffer (ckPointsByX, true, 0, 4 * pointsByX.length, pointsByX, []);
	cmdQueue.enqueueWriteBuffer (ckPointsByY, true, 0, 4 * pointsByY.length, pointsByY, []);
	cmdQueue.enqueueWriteBuffer (ckDiffs, true, 0, 4 * diffs.length, diffs, []);
	cmdQueue.enqueueWriteBuffer (ckStrips, true, 0, 4 * strips.length, strips, []);

	var kernelDiffs = programDiffs.createKernel ("ckDiffs");
	var kernelStrips = programStrips.createKernel ("ckStrips");
	// Compute diffs
	kernelDiffs.setKernelArg(0, ckPointsByX);
	kernelDiffs.setKernelArg(1, ckDiffs);
	kernelDiffs.setKernelArg(2, numPoints, WebCL.types.UINT);
	// +1 to handle the case where numPoints is not even
	var globalWorkSize = [Math.floor((numPoints + 1)/2)];
	var localWorkSize = 1;
	cmdQueue.enqueueNDRangeKernel(kernelDiffs, globalWorkSize.length, [], globalWorkSize, [], []);
	cmdQueue.finish();
	for (maxStripSize = 4; maxStripSize <= numPoints || (maxStripSize > numPoints && (maxStripSize/2 < numPoints)); maxStripSize *= 2){
	    // Compute strips
	    kernelStrips.setKernelArg(0, ckPointsByY);//, WebCL.types.UINT | WebCL.types.VEC3);
	    kernelStrips.setKernelArg(1, ckPointsByX);//, WebCL.types.UINT | WebCL.types.VEC3);
	    kernelStrips.setKernelArg(2, ckDiffs);//, WebCL.types.UINT | WebCL.types.VEC4);
	    kernelStrips.setKernelArg(3, ckStrips);//, WebCL.types.UINT | WebCL.types.VEC2);
	    kernelStrips.setKernelArg(4, numPoints, WebCL.types.UINT);
	    kernelStrips.setKernelArg(5, maxStripSize, WebCL.types.UINT);
	    // + maxStripSize - 1 to handle the case where numPoints is not 
	    // a multiple of maxStripSize e.g. maxStripSize = 4 and numPoints = 15
	    var numStrips = (numPoints + maxStripSize - 1)/maxStripSize;
	    globalWorkSize = [numStrips];
	    localWorkSize = 1;
	    cmdQueue.enqueueNDRangeKernel(kernelStrips, globalWorkSize.length, [], globalWorkSize, [], []);
	    cmdQueue.finish();
	}
	cmdQueue.enqueueReadBuffer(ckDiffs, true, 0, diffs.length * 4, diffs, []);
	var diff = (new Date()).getTime() - start_time;
	if (print_output == undefined)
	{
	    output.innerHTML += "<br/>";
	    output.innerHTML += "OCL Closest Pair: (" + diffs[0] + ", " + diffs[1] + "), (" + diffs[2] + ", " + diffs[3] + ")";
	    output.innerHTML += "<br/>";
	}	    
	// release resources
	/*clReleaseMemObject(ckPointsByX);
	clReleaseMemObject(ckPointsByY);
	clReleaseMemObject(ckDiffs);
	clReleaseMemObject(ckStrips);*/
	//return [[diffs[0], diffs[1]], [diffs[2], diffs[3]]];
	if (return_timing_info == undefined)
	{
	    return 0;
	} else
	{
	    return [diff, diffs[0], diffs[1], diffs[2], diffs[3]];
	}
    } catch(e) {
	document.getElementById("output").innerHTML += "<h3>ERROR:</h3><pre style=\"color:red;\">" + e.message + "</pre>";
	throw e;
    }
}
</script>                 

<script type="text/javascript">
function detectCL() {
  // First check if the WebCL extension is installed at all
  
  if (window.WebCL == undefined) {
    alert("Unfortunately your system does not support WebCL. " +
          "Make sure that you have both the OpenCL driver " +
          "and the WebCL browser extension installed.");
    return false;
  }

  // Get a list of available CL platforms, and another list of the
  // available devices on each platform. If there are no platforms,
  // or no available devices on any platform, then we can conclude
  // that WebCL is not available.

  try {
    var platforms = WebCL.getPlatformIDs();
    var devices = [];
    for (var i in platforms) {
      var plat = platforms[i];
      devices[i] = plat.getDeviceIDs(WebCL.CL_DEVICE_TYPE_ALL);
    }
    //alert("Excellent! Your system does support WebCL.");
  } catch (e) {
    alert("Unfortunately platform or device inquiry failed.");
  }
}


</script>
<script type="text/javascript" src="closest_pair.js"></script>
<script type="text/javascript">
/*	var points    = [];
	for (var i = 0; i < numPoints;  i++) {
	    var cont = true;
	    while (cont) {
		cont = false;
		var p = [Math.floor(Math.random() * 100), Math.floor(Math.random() * 100)];
		for (var j = 0; j < i; j++)
		{
		    if (points[j][0] == p[0] && points[j][1] == p[1])
		    {
			cont = true;
			break;
		    }
		}
		if (!cont) {
		    points[i] = p;
		}
	    }
	    
	}
*/
</script>
<script type="text/javascript" src="timing_code.js"></script>
</head>
<body onload="CL_ClosestPair(points); drawPoints();">
<canvas id="canvas" width="800" height="600"><p>Fallback content goes here.</p></canvas>    
<script type="text/javascript">

  detectCL();
</script>
<div id="output">
</div> 
<button type="button" onclick="TimeOCL_JS();">Time OCL & JS</button>
<div id="TimingInfo"</div>
</body>
</html>
